task_guides.py.1shot.seq (Python 3.12)
[Code]
    File Name: <frozen ..task_guides>
    Object Name: <module>
    Qualified Name: <module>
    Arg Count: 0
    Pos Only Arg Count: 0
    KW Only Arg Count: 0
    Stack Size: 8
    Flags: 0x20000000 (CO_PYARMOR_OBFUSCATED)
    [Names]
        '__assert_armored__'
        'func_analysis'
        'decompilation'
        'specific_vars'
        'vars'
        'args'
        'funcname'
        'summary'
        'func_analysis_output_format'
        'decompilation_output_format'
        'specific_vars_output_format'
        'vars_output_format'
        'args_output_format'
        'funcname_output_format'
        'summary_output_format'
        'TASK_GUIDES'
        'TASK_OUTPUT_FORMATS'
        'random'
        'get_mock_response'
    [Locals+Names]
    [Constants]
        '__pyarmor_assert_54889__'
        '__pyarmor_enter_54890__'
        b'<COAddr>\x01\x00\x00\x1a\x82\x00\x00\x00\x00\x00\x00\x00'
        '1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\n\n5. Data Flow Analysis\nInferring the propagation path of each target variable and argument (cross-function and inter-procedural analysis).\n\n6. Usage Patterns\nSummarize the usage patterns of each variable and argument in target function.\nBased on the usage patterns, judge if the argument and variable is a complex type, such as struct, enum, array, etc.\n\n7. Type Inference\nInfer the type of each argument and variable within target function base on the data flow analysis and usage patterns.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n\n8. Name Recovery\nRecover the name of each argument and variable within target function base on the analysis above.\n\n9. Return Type Inference\nInfer the return type of the target function based on the analysis above.\n\n10. Function Name Recovery\nIf one context function\'s name is stripped (e.g., sub_0xFuncAddr), infer the possible function name based on the analysis above.\nInfer the possible name for target function based on the analysis above, only when the function name is stripped.\n\n11. Comment Generation\n- a. Generate doxygen comments for the whole target function based on the analysis above, including brief, detailed, parameters, return.\n- b. Generate inline comments (end of the line) only for the target function to help user understand the code. Only comment on the key lines, such as some callsites, some important variables and usages, beginning of some loops, etc. LESS IS BETTER!\n\n12. Algorithm and Category Analysis\nAnalyze whether the target function implements a specific algorithm, or is a part of a specific algorithm.\nAnalyze what category the target function belongs to, such as logging, network, crypto, data processing, etc.\nIf it is not one of the well-defined ones, or if you are not sure, use "none".\n\n13. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring each result above.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "ret_type": "int",\n    "funcname": "foo", // recovered meaningful function name for meaningless original name\n    "args": {\n        "a1": ["int","name1","",{}], // type, name, is_complex_type?, and struct or enum details\n        "a2": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ],\n        "a3": ["enum_type_b","name3","enum",{"enum_type_b": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ],\n        "a4": ["char","name4","array","4,4"], // array type, name, array size\n        "a5@del_arg": [], // delete the argument erroneously recovered by decompiler\n        "a6@add_arg": [], // add the argument erroneously omitted by decompiler\n        ...\n    },\n    "vars": {\n        "var1": ["int","name5","",{}],\n        "var2": ["struct_type_b","name6","struct",{"struct_type_b": [\n                ["int","field3",4],\n                ["char","field4",1],\n                ...\n                ]}\n            ],\n        ...\n    },\n    "brief": "brief description",\n    "details": "detailed description",\n    "params": {\n        "a1": "comment for a1",\n        "a2": "comment for a2",\n        ...\n    },\n    "return": "return description",\n    "inline_comment": {\n        "3": "comment for L3",\n        "5": "comment for L5",\n        ...\n    },\n    "category": "functional category or none",\n    "algorithm": "algorithm name or none"\n}\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
        '1. Understand the Task \nWhat should be analyzed in the task.\n<decompilation>: Given a function in decompiled pseudocode, improve the pseudocode, make it closer to source code and more understandable, including doxygen comment, new complex type define (recovery by your analysis), and the source code function.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\n- a. Analyze the behavior of each function, end with detailed analysis of the target function. Start from the calling context, and then analyze the target function based on the calling context.\n- b. List each functionality implementation within the target function in detail.\n\n5. Algorithm and Category Analysis\nAnalyze whether the target function implements a specific algorithm, or is a part of a specific algorithm.\nAnalyze what category the target function belongs to, such as logging, network, data processing, etc.\n\n6. Data Flow Analysis\nInferring the propagation path of each key variable and argument within target function (cross-function and inter-procedural analysis).\n\n7. Usage Patterns\nSummarize the usage patterns of each key variable and argument in target function.\nBased on the usage patterns, judge if the argument and variable is a complex type, such as struct, enum, array, etc.\n\n8. Variable Name and Type Inference\n- a. Infer the type of key argument and variable within target function base on the data flow analysis and usage patterns.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n- b. Recover the name of each argument and variable within target function base on the analysis above.\n\n9. Code Structure Analysis\nAnalyze the code structure and patterns of the target function, and present possible original code structure in its source code.\n\n10. Review and Summary\nReview the analysis check reasoning process.\nOutput the final source code with Doxygen comment wrapped with <Output>...</Output>, such as:\n<Output>\n```C\n/**\n * @brief brief description\n * @details detailed description\n * @param arg1 comment for arg1\n * @param arg2 comment for arg2\n * ...\n * @return return description\n * @category category\n * @algorithm algorithm\n */\nstruct struct_type_a { // present the complex types recovered in the analysis\n    ...\n}\nvoid foo(int arg1, struct_type_a arg2, ...) {\n    ...\n}\n```\n</Output>\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.'
        '\n1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\n\n5. Data Flow Analysis\nInferring the propagation path of the target variable specified by task tag (cross-function and inter-procedural analysis).\n\n6. Usage Patterns\nSummarize the usage pattern of the target variable specified by task tag.\nBased on the usage pattern, judge if the target variable is a structure, enum, array.\n\n7. Type Inference\nInfer the type of the target variable base on the data flow analysis and usage pattern.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n\n8. Name Recovery\nRecover the name of the target variable, specified by task tag, base on the analysis above.\n\n9. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result for the target variable.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "original": ["__int64", "v1"], \n    "prediction": ["char", "name1", "", {}] // type, name, is_complex_type?, and struct or enum details\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__int64", "v1"],\n    "prediction": ["struct_type_a *", "name1", "struct", {"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__uint8","v1"],\n    "prediction": ["enum_type_a","name1","enum",{"enum_type_a": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ]\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__int64 *","v1"],\n    "prediction": ["int","name1","array","4,4"] // array type, name, array size\n}\n</Output>\nThe prediction of the variable is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable is a complex type, such as struct, enum, and array, keep "" if not.\nIf multiple variables are analyzed, the output should be a list of the above format wrapped with one <Output>...</Output>.\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
        '1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\n\n5. Data Flow Analysis\nInferring the propagation path of each target variable (cross-function and inter-procedural analysis).\n\n6. Usage Patterns\nSummarize the usage patterns of each variable in target function.\nBased on the usage patterns, judge if the variable is a complex type, such as struct, enum, array, etc.\n\n7. Type Inference\nInfer the type of each variable within target function base on the data flow analysis and usage patterns.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n\n8. Name Recovery\nRecover the name of each variable within target function base on the analysis above.\n\n9. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result for each target variable.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n[\n    {\n        "original": ["__int64","v1"],\n        "prediction": ["int","name1","",{}] // type, name, is_complex_type?, and struct or enum details\n    },\n    {\n        "original": ["__int64","v2"],\n        "prediction": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__uint8","v3"],\n        "prediction": ["enum_type_b","name3","enum",{"enum_type_b": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__int64 *","v4"],\n        "prediction": ["int","name4","array","4,4"] // array type, name, array size\n    }\n    ...\n]\n</Output>\nThe prediction of the variable is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable is a complex type, such as struct, enum, and array, keep "" if not.\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
        '1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\n\n5. Data Flow Analysis\nInferring the propagation path of each target argument (cross-function and inter-procedural analysis).\n\n6. Usage Patterns\nSummarize the usage patterns of each argument in target function.\nBased on the usage patterns, judge if the argument is a complex type, such as struct, enum, array, etc.\n\n7. Type Inference\nInfer the type of each argument within target function base on the data flow analysis and usage patterns.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n\n8. Name Recovery\nRecover the name of each argument within target function base on the analysis above.\n\n9. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result for each target argument.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n[\n    {\n        "original": ["__int64","a1"],\n        "prediction": ["int","name1","",{}] // type, name, is_complex_type?, and struct or enum details\n    },\n    {\n        "original": ["__int64","a2"],\n        "prediction": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__uint8","a3"],\n        "prediction": ["enum_type_b","name3","enum",{"enum_type_b": [\n                    ["field1","value1",4], // item name, value, and size\n                    ["field2","value2",4],\n                    ...\n                    ]}\n                ]\n    },\n    {\n        "original": ["__int64 *","a4"],\n        "prediction": ["int","name4","array","4,4"] // array type, name, array size\n    },\n    {\n        "original": ["__int64","a5"],\n        "prediction": ["__int64","a5@del_arg","",{}] // delete the argument erroneously recovered by decompiler\n    }\n    {\n        "original": [],\n        "prediction": ["char *","name6@add_arg","",{}] / add the argument erroneously omitted by decompiler\n    }\n    ...\n]\n</Output>\nThe prediction of the argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the argument is a complex type, such as struct, enum, and array, keep "" if not.\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
        '\n1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\nStart from the context functions, and then analyze the target function based on the calling context.\n\n5. Function Name Recovery\nInfer the possible function names for all functions based on the analysis above.\n\n6. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result.\nSummarize the final results wrapped with <Output>...</Output>, such as:\n<Output>\n[\n{"original": "sub_0xFuncAddr", "prediction": "foo"},\n...\n]\n</Output>\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
        '\n1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\nStart from the context functions, and then analyze the target function based on the calling context.\n\n5. Algorithm and Category Analysis\nAnalyze whether the target function implements a specific algorithm, or is a part of a specific algorithm.\nAnalyze what category the target function belongs to, such as logging, network, data processing, etc.\nIf it is not one of the well-defined ones, or if you are not sure, use "none".\n\n6. Comment Generation\n- a. Generate doxygen comments for the whole target function based on the analysis above, including brief, detailed, parameters, return.\n- b. Generate inline comments (end of the line) for the target function for only key lines based on the analysis above to help user understand the code. Only comment on the key lines, such as some callsites, some important variables and usages, beginning of some loops, etc.\n\n7. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "brief": "brief description",\n    "details": "detailed description",\n    "params": {\n        "arg1": "comment for arg1",\n        "arg2": "comment for arg2",\n        ...\n    },\n    "return": "return description",\n    "inline_comment": {\n        "3": "comment for L3",\n        "5": "comment for L5",\n        ...\n    },\n    "category": "functional category or none",\n    "algorithm": "algorithm name or none"\n}\n</Output>\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
        '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "ret_type": "int",\n    "funcname": "foo", // recovered meaningful function name for meaningless original name\n    "args": {\n        "a1": ["int","name1","",{}], // type, name, is_complex_type?, and struct or enum details\n        "a2": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ],\n        "a3": ["enum_type_b","name3","enum",{"enum_type_b": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ],\n        "a4": ["char","name4","array","4,4"], // array type, name, array size\n        "a5@del_arg": [], // delete the argument erroneously recovered by decompiler\n        "a6@add_arg": [], // add the argument erroneously omitted by decompiler\n        ...\n    },\n    "vars": {\n        "var1": ["int","name5","",{}],\n        "var2": ["struct_type_b","name6","struct",{"struct_type_b": [\n                ["int","field3",4],\n                ["char","field4",1],\n                ...\n                ]}\n            ],\n        ...\n    },\n    "brief": "brief description",\n    "details": "detailed description",\n    "params": {\n        "a1": "comment for a1",\n        "a2": "comment for a2",\n        ...\n    },\n    "return": "return description",\n    "inline_comment": {\n        "3": "comment for L3",\n        "5": "comment for L5",\n        ...\n    },\n    "category": "functional category or none",\n    "algorithm": "algorithm name or none"\n}\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\n'
        '\nthe final results should be the decompiled source code with Doxygen comment wrapped with <Output>...</Output>, as well as the complex types recovered in the analysis, such as:\n<Output>\n```C\n/**\n * @brief brief description\n * @details detailed description\n * @param arg1 comment for arg1\n * @param arg2 comment for arg2\n * ...\n * @return return description\n * @category category\n * @algorithm algorithm\n */\nstruct struct_type_a { // present the complex types recovered in the analysis\n    ...\n}\nvoid foo(int arg1, struct_type_a arg2, ...) {\n    ...\n}\n```\n</Output>\n'
        '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "original": ["__int64", "v1"], \n    "prediction": ["char", "name1", "", {}] // type, name, is_complex_type?, and struct or enum details\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__int64", "v1"],\n    "prediction": ["struct_type_a *", "name1", "struct", {"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__uint8","v1"],\n    "prediction": ["enum_type_a","name1","enum",{"enum_type_a": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ]\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__int64 *","v1"],\n    "prediction": ["int","name1","array","4,4"] // array type, name, array size\n}\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\nIf multiple variables/arguments are analyzed, the output should be a list of the above format wrapped with one <Output>...</Output>.\n'
        '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n[\n    {\n        "original": ["__int64","v1"],\n        "prediction": ["int","name1","",{}] // type, name, is_complex_type?, and struct or enum details\n    },\n    {\n        "original": ["__int64","v2"],\n        "prediction": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__uint8","v3"],\n        "prediction": ["enum_type_b","name3","enum",{"enum_type_b": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__int64 *","v4"],\n        "prediction": ["int","name4","array","4,4"] // array type, name, array size\n    }\n    ...\n]\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\n'
        '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n[\n    {\n        "original": ["__int64","a1"],\n        "prediction": ["int","name1","",{}] // type, name, is_complex_type?, and struct or enum details\n    },\n    {\n        "original": ["__int64","a2"],\n        "prediction": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__uint8","a3"],\n        "prediction": ["enum_type_b","name3","enum",{"enum_type_b": [\n                    ["field1","value1",4], // item name, value, and size\n                    ["field2","value2",4],\n                    ...\n                    ]}\n                ]\n    },\n    {\n        "original": ["__int64 *","a4"],\n        "prediction": ["int","name4","array","4,4"] // array type, name, array size\n    },\n    {\n        "original": ["__int64","a5"],\n        "prediction": ["__int64","a5@del_arg","",{}] // delete the argument erroneously recovered by decompiler\n    }\n    {\n        "original": [],\n        "prediction": ["char *","name6@add_arg","",{}] / add the argument erroneously omitted by decompiler\n    }\n    ...\n]\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\n'
        '\nThe final results should be wrapped with <Output>...</Output>, such as:\n<Output>\n[\n{"original": "sub_0xFuncAddr", "prediction": "foo"},\n...\n]\n</Output>\n'
        '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "brief": "brief description",\n    "details": "detailed description",\n    "params": {\n        "arg1": "comment for arg1",\n        "arg2": "comment for arg2",\n        ...\n    },\n    "return": "return description",\n    "inline_comment": {\n        "3": "comment for L3",\n        "5": "comment for L5",\n        ...\n    },\n    "category": "functional category or none",\n    "algorithm": "algorithm name or none"\n}\n</Output>\n'
        (
            '<func-analysis>'
            '<decompilation>'
            '<specific-vars>'
            '<vars>'
            '<args>'
            '<funcname>'
            '<summary>'
        )
        0
        None
        [Code]
            File Name: <frozen ..task_guides>
            Object Name: get_mock_response
            Qualified Name: get_mock_response
            Arg Count: 1
            Pos Only Arg Count: 0
            KW Only Arg Count: 0
            Stack Size: 6
            Flags: 0x20000003 (CO_OPTIMIZED | CO_NEWLOCALS | CO_PYARMOR_OBFUSCATED)
            [Names]
                'json'
                'os'
                'path'
                'dirname'
                '__file__'
                'join'
                'exists'
                'Exception'
                'open'
                'load'
                'random'
                'choice'
            [Locals+Names]
                'task_tag'
                '__assert_armored__'
                '_var_var_0'
                '_var_var_1'
                '_var_var_2'
                '_var_var_3'
                '_var_var_4'
            [Constants]
                None
                '__pyarmor_assert_54892__'
                '__pyarmor_enter_54893__'
                b'<COAddr>\x01\x00\x00\x1a\xb8\x01\x00\x00\x00\x00\x00\x00'
                0
                'debug_mock.json'
                '[!💥] mock response file not found, turn off Mock Mode in settings if you are not a developer.'
                'r'
                'utf-8'
                (
                    'encoding'
                )
                '2'
                '__pyarmor_exit_54894__'
            [Disassembly]
                0       NOP                             
                2       NOP                             
                4       PUSH_NULL                       
                6       LOAD_CONST                      2: '__pyarmor_enter_54893__'
                8       LOAD_CONST                      3: b'<COAddr>\x01\x00\x00\x1a\xb8\x01\x00\x00\x00\x00\x00\x00'
                10      BUILD_TUPLE                     1
                12      CALL_FUNCTION_EX                0
                14      POP_TOP                         
                16      RESUME                          0
                18      NOP                             
                20      NOP                             
                22      NOP                             
                24      NOP                             
                26      NOP                             
                28      LOAD_CONST                      4: 0
                30      LOAD_CONST                      0: None
                32      IMPORT_NAME                     0: json
                34      STORE_FAST                      2: _var_var_0
                36      LOAD_CONST                      4: 0
                38      LOAD_CONST                      0: None
                40      IMPORT_NAME                     1: os
                42      STORE_FAST                      3: _var_var_1
                44      LOAD_FAST                       3: _var_var_1
                46      LOAD_ATTR                       4: path
                66      LOAD_ATTR                       7: dirname
                86      LOAD_GLOBAL                     8: __file__
                96      CALL                            1
                104     STORE_FAST                      4: _var_var_2
                106     LOAD_FAST                       3: _var_var_1
                108     LOAD_ATTR                       4: path
                128     LOAD_ATTR                       11: join
                148     LOAD_FAST                       4: _var_var_2
                150     LOAD_CONST                      5: 'debug_mock.json'
                152     CALL                            2
                160     STORE_FAST                      4: _var_var_2
                162     LOAD_FAST                       3: _var_var_1
                164     LOAD_ATTR                       4: path
                184     LOAD_ATTR                       13: exists
                204     LOAD_FAST                       4: _var_var_2
                206     CALL                            1
                214     POP_JUMP_IF_TRUE                11 (to 238)
                216     LOAD_GLOBAL                     15: NULL + Exception
                226     LOAD_CONST                      6: '[!💥] mock response file not found, turn off Mock Mode in settings if you are not a developer.'
                228     CALL                            1
                236     RAISE_VARARGS                   1
                238     LOAD_GLOBAL                     17: NULL + open
                248     LOAD_FAST                       4: _var_var_2
                250     LOAD_CONST                      7: 'r'
                252     LOAD_CONST                      8: 'utf-8'
                254     KW_NAMES                        9: ('encoding',)
                256     CALL                            3
                264     BEFORE_WITH                     
                266     STORE_FAST                      5: _var_var_3
                268     LOAD_FAST                       2: _var_var_0
                270     LOAD_ATTR                       19: load
                290     LOAD_FAST                       5: _var_var_3
                292     CALL                            1
                300     STORE_FAST                      6: _var_var_4
                302     LOAD_CONST                      0: None
                304     LOAD_CONST                      0: None
                306     LOAD_CONST                      0: None
                308     CALL                            2
                316     POP_TOP                         
                318     LOAD_FAST                       0: task_tag
                320     LOAD_CONST                      10: '2'
                322     BINARY_OP                       0 (+)
                326     LOAD_FAST_CHECK                 6: _var_var_4
                328     CONTAINS_OP                     0 (in)
                330     POP_JUMP_IF_FALSE               41 (to 414)
                332     LOAD_GLOBAL                     21: NULL + random
                342     LOAD_ATTR                       22: choice
                362     LOAD_FAST                       6: _var_var_4
                364     LOAD_FAST                       0: task_tag
                366     BINARY_SUBSCR                   
                370     LOAD_FAST                       6: _var_var_4
                372     LOAD_FAST                       0: task_tag
                374     LOAD_CONST                      10: '2'
                376     BINARY_OP                       0 (+)
                380     BINARY_SUBSCR                   
                384     BUILD_LIST                      2
                386     CALL                            1
                394     NOP                             
                396     NOP                             
                398     NOP                             
                400     JUMP_FORWARD                    46 (to 494)
                402     CALL                            1
                410     POP_TOP                         
                412     RETURN_VALUE                    
                414     LOAD_FAST                       6: _var_var_4
                416     LOAD_FAST                       0: task_tag
                418     BINARY_SUBSCR                   
                422     NOP                             
                424     NOP                             
                426     NOP                             
                428     JUMP_FORWARD                    32 (to 494)
                430     CALL                            1
                438     POP_TOP                         
                440     RETURN_VALUE                    
                442     PUSH_EXC_INFO                   
                444     WITH_EXCEPT_START               
                446     POP_JUMP_IF_TRUE                1 (to 450)
                448     RERAISE                         2
                450     POP_TOP                         
                452     POP_EXCEPT                      
                454     POP_TOP                         
                456     POP_TOP                         
                458     JUMP_BACKWARD                   71 (to 318)
                460     COPY                            3
                462     POP_EXCEPT                      
                464     RERAISE                         1
                466     PUSH_EXC_INFO                   
                468     PUSH_NULL                       
                470     LOAD_CONST                      11: '__pyarmor_exit_54894__'
                472     NOP                             
                474     LOAD_CONST                      3: b'<COAddr>\x01\x00\x00\x1a\xb8\x01\x00\x00\x00\x00\x00\x00'
                476     CALL                            1
                484     POP_TOP                         
                486     RERAISE                         0
                488     COPY                            3
                490     POP_EXCEPT                      
                492     RERAISE                         1
                494     PUSH_NULL                       
                496     LOAD_CONST                      11: '__pyarmor_exit_54894__'
                498     LOAD_CONST                      3: b'<COAddr>\x01\x00\x00\x1a\xb8\x01\x00\x00\x00\x00\x00\x00'
                500     BUILD_TUPLE                     1
                502     CALL_FUNCTION_EX                0
                504     POP_TOP                         
                506     RETURN_VALUE                    
        '__pyarmor_exit_54891__'
    [Disassembly]
        0       NOP                             
        2       NOP                             
        4       PUSH_NULL                       
        6       LOAD_CONST                      1: '__pyarmor_enter_54890__'
        8       LOAD_CONST                      2: b'<COAddr>\x01\x00\x00\x1a\x82\x00\x00\x00\x00\x00\x00\x00'
        10      BUILD_TUPLE                     1
        12      CALL_FUNCTION_EX                0
        14      POP_TOP                         
        16      RESUME                          0
        18      NOP                             
        20      NOP                             
        22      NOP                             
        24      NOP                             
        26      LOAD_CONST                      3: '1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\n\n5. Data Flow Analysis\nInferring the propagation path of each target variable and argument (cross-function and inter-procedural analysis).\n\n6. Usage Patterns\nSummarize the usage patterns of each variable and argument in target function.\nBased on the usage patterns, judge if the argument and variable is a complex type, such as struct, enum, array, etc.\n\n7. Type Inference\nInfer the type of each argument and variable within target function base on the data flow analysis and usage patterns.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n\n8. Name Recovery\nRecover the name of each argument and variable within target function base on the analysis above.\n\n9. Return Type Inference\nInfer the return type of the target function based on the analysis above.\n\n10. Function Name Recovery\nIf one context function\'s name is stripped (e.g., sub_0xFuncAddr), infer the possible function name based on the analysis above.\nInfer the possible name for target function based on the analysis above, only when the function name is stripped.\n\n11. Comment Generation\n- a. Generate doxygen comments for the whole target function based on the analysis above, including brief, detailed, parameters, return.\n- b. Generate inline comments (end of the line) only for the target function to help user understand the code. Only comment on the key lines, such as some callsites, some important variables and usages, beginning of some loops, etc. LESS IS BETTER!\n\n12. Algorithm and Category Analysis\nAnalyze whether the target function implements a specific algorithm, or is a part of a specific algorithm.\nAnalyze what category the target function belongs to, such as logging, network, crypto, data processing, etc.\nIf it is not one of the well-defined ones, or if you are not sure, use "none".\n\n13. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring each result above.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "ret_type": "int",\n    "funcname": "foo", // recovered meaningful function name for meaningless original name\n    "args": {\n        "a1": ["int","name1","",{}], // type, name, is_complex_type?, and struct or enum details\n        "a2": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ],\n        "a3": ["enum_type_b","name3","enum",{"enum_type_b": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ],\n        "a4": ["char","name4","array","4,4"], // array type, name, array size\n        "a5@del_arg": [], // delete the argument erroneously recovered by decompiler\n        "a6@add_arg": [], // add the argument erroneously omitted by decompiler\n        ...\n    },\n    "vars": {\n        "var1": ["int","name5","",{}],\n        "var2": ["struct_type_b","name6","struct",{"struct_type_b": [\n                ["int","field3",4],\n                ["char","field4",1],\n                ...\n                ]}\n            ],\n        ...\n    },\n    "brief": "brief description",\n    "details": "detailed description",\n    "params": {\n        "a1": "comment for a1",\n        "a2": "comment for a2",\n        ...\n    },\n    "return": "return description",\n    "inline_comment": {\n        "3": "comment for L3",\n        "5": "comment for L5",\n        ...\n    },\n    "category": "functional category or none",\n    "algorithm": "algorithm name or none"\n}\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
        28      STORE_NAME                      1: func_analysis
        30      LOAD_CONST                      4: '1. Understand the Task \nWhat should be analyzed in the task.\n<decompilation>: Given a function in decompiled pseudocode, improve the pseudocode, make it closer to source code and more understandable, including doxygen comment, new complex type define (recovery by your analysis), and the source code function.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\n- a. Analyze the behavior of each function, end with detailed analysis of the target function. Start from the calling context, and then analyze the target function based on the calling context.\n- b. List each functionality implementation within the target function in detail.\n\n5. Algorithm and Category Analysis\nAnalyze whether the target function implements a specific algorithm, or is a part of a specific algorithm.\nAnalyze what category the target function belongs to, such as logging, network, data processing, etc.\n\n6. Data Flow Analysis\nInferring the propagation path of each key variable and argument within target function (cross-function and inter-procedural analysis).\n\n7. Usage Patterns\nSummarize the usage patterns of each key variable and argument in target function.\nBased on the usage patterns, judge if the argument and variable is a complex type, such as struct, enum, array, etc.\n\n8. Variable Name and Type Inference\n- a. Infer the type of key argument and variable within target function base on the data flow analysis and usage patterns.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n- b. Recover the name of each argument and variable within target function base on the analysis above.\n\n9. Code Structure Analysis\nAnalyze the code structure and patterns of the target function, and present possible original code structure in its source code.\n\n10. Review and Summary\nReview the analysis check reasoning process.\nOutput the final source code with Doxygen comment wrapped with <Output>...</Output>, such as:\n<Output>\n```C\n/**\n * @brief brief description\n * @details detailed description\n * @param arg1 comment for arg1\n * @param arg2 comment for arg2\n * ...\n * @return return description\n * @category category\n * @algorithm algorithm\n */\nstruct struct_type_a { // present the complex types recovered in the analysis\n    ...\n}\nvoid foo(int arg1, struct_type_a arg2, ...) {\n    ...\n}\n```\n</Output>\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.'
        32      STORE_NAME                      2: decompilation
        34      LOAD_CONST                      5: '\n1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\n\n5. Data Flow Analysis\nInferring the propagation path of the target variable specified by task tag (cross-function and inter-procedural analysis).\n\n6. Usage Patterns\nSummarize the usage pattern of the target variable specified by task tag.\nBased on the usage pattern, judge if the target variable is a structure, enum, array.\n\n7. Type Inference\nInfer the type of the target variable base on the data flow analysis and usage pattern.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n\n8. Name Recovery\nRecover the name of the target variable, specified by task tag, base on the analysis above.\n\n9. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result for the target variable.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "original": ["__int64", "v1"], \n    "prediction": ["char", "name1", "", {}] // type, name, is_complex_type?, and struct or enum details\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__int64", "v1"],\n    "prediction": ["struct_type_a *", "name1", "struct", {"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__uint8","v1"],\n    "prediction": ["enum_type_a","name1","enum",{"enum_type_a": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ]\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__int64 *","v1"],\n    "prediction": ["int","name1","array","4,4"] // array type, name, array size\n}\n</Output>\nThe prediction of the variable is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable is a complex type, such as struct, enum, and array, keep "" if not.\nIf multiple variables are analyzed, the output should be a list of the above format wrapped with one <Output>...</Output>.\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
        36      STORE_NAME                      3: specific_vars
        38      LOAD_CONST                      6: '1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\n\n5. Data Flow Analysis\nInferring the propagation path of each target variable (cross-function and inter-procedural analysis).\n\n6. Usage Patterns\nSummarize the usage patterns of each variable in target function.\nBased on the usage patterns, judge if the variable is a complex type, such as struct, enum, array, etc.\n\n7. Type Inference\nInfer the type of each variable within target function base on the data flow analysis and usage patterns.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n\n8. Name Recovery\nRecover the name of each variable within target function base on the analysis above.\n\n9. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result for each target variable.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n[\n    {\n        "original": ["__int64","v1"],\n        "prediction": ["int","name1","",{}] // type, name, is_complex_type?, and struct or enum details\n    },\n    {\n        "original": ["__int64","v2"],\n        "prediction": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__uint8","v3"],\n        "prediction": ["enum_type_b","name3","enum",{"enum_type_b": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__int64 *","v4"],\n        "prediction": ["int","name4","array","4,4"] // array type, name, array size\n    }\n    ...\n]\n</Output>\nThe prediction of the variable is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable is a complex type, such as struct, enum, and array, keep "" if not.\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
        40      STORE_NAME                      4: vars
        42      LOAD_CONST                      7: '1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\n\n5. Data Flow Analysis\nInferring the propagation path of each target argument (cross-function and inter-procedural analysis).\n\n6. Usage Patterns\nSummarize the usage patterns of each argument in target function.\nBased on the usage patterns, judge if the argument is a complex type, such as struct, enum, array, etc.\n\n7. Type Inference\nInfer the type of each argument within target function base on the data flow analysis and usage patterns.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n\n8. Name Recovery\nRecover the name of each argument within target function base on the analysis above.\n\n9. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result for each target argument.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n[\n    {\n        "original": ["__int64","a1"],\n        "prediction": ["int","name1","",{}] // type, name, is_complex_type?, and struct or enum details\n    },\n    {\n        "original": ["__int64","a2"],\n        "prediction": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__uint8","a3"],\n        "prediction": ["enum_type_b","name3","enum",{"enum_type_b": [\n                    ["field1","value1",4], // item name, value, and size\n                    ["field2","value2",4],\n                    ...\n                    ]}\n                ]\n    },\n    {\n        "original": ["__int64 *","a4"],\n        "prediction": ["int","name4","array","4,4"] // array type, name, array size\n    },\n    {\n        "original": ["__int64","a5"],\n        "prediction": ["__int64","a5@del_arg","",{}] // delete the argument erroneously recovered by decompiler\n    }\n    {\n        "original": [],\n        "prediction": ["char *","name6@add_arg","",{}] / add the argument erroneously omitted by decompiler\n    }\n    ...\n]\n</Output>\nThe prediction of the argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the argument is a complex type, such as struct, enum, and array, keep "" if not.\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
        44      STORE_NAME                      5: args
        46      LOAD_CONST                      8: '\n1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\nStart from the context functions, and then analyze the target function based on the calling context.\n\n5. Function Name Recovery\nInfer the possible function names for all functions based on the analysis above.\n\n6. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result.\nSummarize the final results wrapped with <Output>...</Output>, such as:\n<Output>\n[\n{"original": "sub_0xFuncAddr", "prediction": "foo"},\n...\n]\n</Output>\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
        48      STORE_NAME                      6: funcname
        50      LOAD_CONST                      9: '\n1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\nStart from the context functions, and then analyze the target function based on the calling context.\n\n5. Algorithm and Category Analysis\nAnalyze whether the target function implements a specific algorithm, or is a part of a specific algorithm.\nAnalyze what category the target function belongs to, such as logging, network, data processing, etc.\nIf it is not one of the well-defined ones, or if you are not sure, use "none".\n\n6. Comment Generation\n- a. Generate doxygen comments for the whole target function based on the analysis above, including brief, detailed, parameters, return.\n- b. Generate inline comments (end of the line) for the target function for only key lines based on the analysis above to help user understand the code. Only comment on the key lines, such as some callsites, some important variables and usages, beginning of some loops, etc.\n\n7. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "brief": "brief description",\n    "details": "detailed description",\n    "params": {\n        "arg1": "comment for arg1",\n        "arg2": "comment for arg2",\n        ...\n    },\n    "return": "return description",\n    "inline_comment": {\n        "3": "comment for L3",\n        "5": "comment for L5",\n        ...\n    },\n    "category": "functional category or none",\n    "algorithm": "algorithm name or none"\n}\n</Output>\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
        52      STORE_NAME                      7: summary
        54      LOAD_CONST                      10: '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "ret_type": "int",\n    "funcname": "foo", // recovered meaningful function name for meaningless original name\n    "args": {\n        "a1": ["int","name1","",{}], // type, name, is_complex_type?, and struct or enum details\n        "a2": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ],\n        "a3": ["enum_type_b","name3","enum",{"enum_type_b": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ],\n        "a4": ["char","name4","array","4,4"], // array type, name, array size\n        "a5@del_arg": [], // delete the argument erroneously recovered by decompiler\n        "a6@add_arg": [], // add the argument erroneously omitted by decompiler\n        ...\n    },\n    "vars": {\n        "var1": ["int","name5","",{}],\n        "var2": ["struct_type_b","name6","struct",{"struct_type_b": [\n                ["int","field3",4],\n                ["char","field4",1],\n                ...\n                ]}\n            ],\n        ...\n    },\n    "brief": "brief description",\n    "details": "detailed description",\n    "params": {\n        "a1": "comment for a1",\n        "a2": "comment for a2",\n        ...\n    },\n    "return": "return description",\n    "inline_comment": {\n        "3": "comment for L3",\n        "5": "comment for L5",\n        ...\n    },\n    "category": "functional category or none",\n    "algorithm": "algorithm name or none"\n}\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\n'
        56      STORE_NAME                      8: func_analysis_output_format
        58      LOAD_CONST                      11: '\nthe final results should be the decompiled source code with Doxygen comment wrapped with <Output>...</Output>, as well as the complex types recovered in the analysis, such as:\n<Output>\n```C\n/**\n * @brief brief description\n * @details detailed description\n * @param arg1 comment for arg1\n * @param arg2 comment for arg2\n * ...\n * @return return description\n * @category category\n * @algorithm algorithm\n */\nstruct struct_type_a { // present the complex types recovered in the analysis\n    ...\n}\nvoid foo(int arg1, struct_type_a arg2, ...) {\n    ...\n}\n```\n</Output>\n'
        60      STORE_NAME                      9: decompilation_output_format
        62      LOAD_CONST                      12: '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "original": ["__int64", "v1"], \n    "prediction": ["char", "name1", "", {}] // type, name, is_complex_type?, and struct or enum details\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__int64", "v1"],\n    "prediction": ["struct_type_a *", "name1", "struct", {"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__uint8","v1"],\n    "prediction": ["enum_type_a","name1","enum",{"enum_type_a": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ]\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__int64 *","v1"],\n    "prediction": ["int","name1","array","4,4"] // array type, name, array size\n}\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\nIf multiple variables/arguments are analyzed, the output should be a list of the above format wrapped with one <Output>...</Output>.\n'
        64      STORE_NAME                      10: specific_vars_output_format
        66      LOAD_CONST                      13: '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n[\n    {\n        "original": ["__int64","v1"],\n        "prediction": ["int","name1","",{}] // type, name, is_complex_type?, and struct or enum details\n    },\n    {\n        "original": ["__int64","v2"],\n        "prediction": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__uint8","v3"],\n        "prediction": ["enum_type_b","name3","enum",{"enum_type_b": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__int64 *","v4"],\n        "prediction": ["int","name4","array","4,4"] // array type, name, array size\n    }\n    ...\n]\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\n'
        68      STORE_NAME                      11: vars_output_format
        70      LOAD_CONST                      14: '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n[\n    {\n        "original": ["__int64","a1"],\n        "prediction": ["int","name1","",{}] // type, name, is_complex_type?, and struct or enum details\n    },\n    {\n        "original": ["__int64","a2"],\n        "prediction": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__uint8","a3"],\n        "prediction": ["enum_type_b","name3","enum",{"enum_type_b": [\n                    ["field1","value1",4], // item name, value, and size\n                    ["field2","value2",4],\n                    ...\n                    ]}\n                ]\n    },\n    {\n        "original": ["__int64 *","a4"],\n        "prediction": ["int","name4","array","4,4"] // array type, name, array size\n    },\n    {\n        "original": ["__int64","a5"],\n        "prediction": ["__int64","a5@del_arg","",{}] // delete the argument erroneously recovered by decompiler\n    }\n    {\n        "original": [],\n        "prediction": ["char *","name6@add_arg","",{}] / add the argument erroneously omitted by decompiler\n    }\n    ...\n]\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\n'
        72      STORE_NAME                      12: args_output_format
        74      LOAD_CONST                      15: '\nThe final results should be wrapped with <Output>...</Output>, such as:\n<Output>\n[\n{"original": "sub_0xFuncAddr", "prediction": "foo"},\n...\n]\n</Output>\n'
        76      STORE_NAME                      13: funcname_output_format
        78      LOAD_CONST                      16: '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "brief": "brief description",\n    "details": "detailed description",\n    "params": {\n        "arg1": "comment for arg1",\n        "arg2": "comment for arg2",\n        ...\n    },\n    "return": "return description",\n    "inline_comment": {\n        "3": "comment for L3",\n        "5": "comment for L5",\n        ...\n    },\n    "category": "functional category or none",\n    "algorithm": "algorithm name or none"\n}\n</Output>\n'
        80      STORE_NAME                      14: summary_output_format
        82      LOAD_NAME                       1: func_analysis
        84      LOAD_NAME                       2: decompilation
        86      LOAD_NAME                       3: specific_vars
        88      LOAD_NAME                       4: vars
        90      LOAD_NAME                       5: args
        92      LOAD_NAME                       6: funcname
        94      LOAD_NAME                       7: summary
        96      LOAD_CONST                      17: ('<func-analysis>', '<decompilation>', '<specific-vars>', '<vars>', '<args>', '<funcname>', '<summary>')
        98      BUILD_CONST_KEY_MAP             7
        100     STORE_NAME                      15: TASK_GUIDES
        102     LOAD_NAME                       8: func_analysis_output_format
        104     LOAD_NAME                       9: decompilation_output_format
        106     LOAD_NAME                       10: specific_vars_output_format
        108     LOAD_NAME                       11: vars_output_format
        110     LOAD_NAME                       12: args_output_format
        112     LOAD_NAME                       13: funcname_output_format
        114     LOAD_NAME                       14: summary_output_format
        116     LOAD_CONST                      17: ('<func-analysis>', '<decompilation>', '<specific-vars>', '<vars>', '<args>', '<funcname>', '<summary>')
        118     BUILD_CONST_KEY_MAP             7
        120     STORE_NAME                      16: TASK_OUTPUT_FORMATS
        122     LOAD_CONST                      18: 0
        124     LOAD_CONST                      19: None
        126     IMPORT_NAME                     17: random
        128     STORE_NAME                      17: random
        130     LOAD_CONST                      20: <CODE> get_mock_response
        132     MAKE_FUNCTION                   0
        134     STORE_NAME                      18: get_mock_response
        136     LOAD_CONST                      19: None
        138     NOP                             
        140     NOP                             
        142     NOP                             
        144     JUMP_FORWARD                    19 (to 184)
        152     POP_TOP                         
        154     RETURN_CONST                    19: None
        156     PUSH_EXC_INFO                   
        158     PUSH_NULL                       
        160     LOAD_CONST                      21: '__pyarmor_exit_54891__'
        162     NOP                             
        164     LOAD_CONST                      2: b'<COAddr>\x01\x00\x00\x1a\x82\x00\x00\x00\x00\x00\x00\x00'
        166     CALL                            1
        174     POP_TOP                         
        176     RERAISE                         0
        178     COPY                            3
        180     POP_EXCEPT                      
        182     RERAISE                         1
        184     PUSH_NULL                       
        186     LOAD_CONST                      21: '__pyarmor_exit_54891__'
        188     LOAD_CONST                      2: b'<COAddr>\x01\x00\x00\x1a\x82\x00\x00\x00\x00\x00\x00\x00'
        190     BUILD_TUPLE                     1
        192     CALL_FUNCTION_EX                0
        194     POP_TOP                         
        196     RETURN_VALUE                    
