# Source Generated with Decompyle++
# File: task_guides.py.1shot.seq (Python 3.12)

'__pyarmor_enter_54890__(...)'
func_analysis = '1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\n\n5. Data Flow Analysis\nInferring the propagation path of each target variable and argument (cross-function and inter-procedural analysis).\n\n6. Usage Patterns\nSummarize the usage patterns of each variable and argument in target function.\nBased on the usage patterns, judge if the argument and variable is a complex type, such as struct, enum, array, etc.\n\n7. Type Inference\nInfer the type of each argument and variable within target function base on the data flow analysis and usage patterns.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n\n8. Name Recovery\nRecover the name of each argument and variable within target function base on the analysis above.\n\n9. Return Type Inference\nInfer the return type of the target function based on the analysis above.\n\n10. Function Name Recovery\nIf one context function\'s name is stripped (e.g., sub_0xFuncAddr), infer the possible function name based on the analysis above.\nInfer the possible name for target function based on the analysis above, only when the function name is stripped.\n\n11. Comment Generation\n- a. Generate doxygen comments for the whole target function based on the analysis above, including brief, detailed, parameters, return.\n- b. Generate inline comments (end of the line) only for the target function to help user understand the code. Only comment on the key lines, such as some callsites, some important variables and usages, beginning of some loops, etc. LESS IS BETTER!\n\n12. Algorithm and Category Analysis\nAnalyze whether the target function implements a specific algorithm, or is a part of a specific algorithm.\nAnalyze what category the target function belongs to, such as logging, network, crypto, data processing, etc.\nIf it is not one of the well-defined ones, or if you are not sure, use "none".\n\n13. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring each result above.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "ret_type": "int",\n    "funcname": "foo", // recovered meaningful function name for meaningless original name\n    "args": {\n        "a1": ["int","name1","",{}], // type, name, is_complex_type?, and struct or enum details\n        "a2": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ],\n        "a3": ["enum_type_b","name3","enum",{"enum_type_b": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ],\n        "a4": ["char","name4","array","4,4"], // array type, name, array size\n        "a5@del_arg": [], // delete the argument erroneously recovered by decompiler\n        "a6@add_arg": [], // add the argument erroneously omitted by decompiler\n        ...\n    },\n    "vars": {\n        "var1": ["int","name5","",{}],\n        "var2": ["struct_type_b","name6","struct",{"struct_type_b": [\n                ["int","field3",4],\n                ["char","field4",1],\n                ...\n                ]}\n            ],\n        ...\n    },\n    "brief": "brief description",\n    "details": "detailed description",\n    "params": {\n        "a1": "comment for a1",\n        "a2": "comment for a2",\n        ...\n    },\n    "return": "return description",\n    "inline_comment": {\n        "3": "comment for L3",\n        "5": "comment for L5",\n        ...\n    },\n    "category": "functional category or none",\n    "algorithm": "algorithm name or none"\n}\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
decompilation = '1. Understand the Task \nWhat should be analyzed in the task.\n<decompilation>: Given a function in decompiled pseudocode, improve the pseudocode, make it closer to source code and more understandable, including doxygen comment, new complex type define (recovery by your analysis), and the source code function.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\n- a. Analyze the behavior of each function, end with detailed analysis of the target function. Start from the calling context, and then analyze the target function based on the calling context.\n- b. List each functionality implementation within the target function in detail.\n\n5. Algorithm and Category Analysis\nAnalyze whether the target function implements a specific algorithm, or is a part of a specific algorithm.\nAnalyze what category the target function belongs to, such as logging, network, data processing, etc.\n\n6. Data Flow Analysis\nInferring the propagation path of each key variable and argument within target function (cross-function and inter-procedural analysis).\n\n7. Usage Patterns\nSummarize the usage patterns of each key variable and argument in target function.\nBased on the usage patterns, judge if the argument and variable is a complex type, such as struct, enum, array, etc.\n\n8. Variable Name and Type Inference\n- a. Infer the type of key argument and variable within target function base on the data flow analysis and usage patterns.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n- b. Recover the name of each argument and variable within target function base on the analysis above.\n\n9. Code Structure Analysis\nAnalyze the code structure and patterns of the target function, and present possible original code structure in its source code.\n\n10. Review and Summary\nReview the analysis check reasoning process.\nOutput the final source code with Doxygen comment wrapped with <Output>...</Output>, such as:\n<Output>\n```C\n/**\n * @brief brief description\n * @details detailed description\n * @param arg1 comment for arg1\n * @param arg2 comment for arg2\n * ...\n * @return return description\n * @category category\n * @algorithm algorithm\n */\nstruct struct_type_a { // present the complex types recovered in the analysis\n    ...\n}\nvoid foo(int arg1, struct_type_a arg2, ...) {\n    ...\n}\n```\n</Output>\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.'
specific_vars = '\n1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\n\n5. Data Flow Analysis\nInferring the propagation path of the target variable specified by task tag (cross-function and inter-procedural analysis).\n\n6. Usage Patterns\nSummarize the usage pattern of the target variable specified by task tag.\nBased on the usage pattern, judge if the target variable is a structure, enum, array.\n\n7. Type Inference\nInfer the type of the target variable base on the data flow analysis and usage pattern.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n\n8. Name Recovery\nRecover the name of the target variable, specified by task tag, base on the analysis above.\n\n9. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result for the target variable.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "original": ["__int64", "v1"], \n    "prediction": ["char", "name1", "", {}] // type, name, is_complex_type?, and struct or enum details\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__int64", "v1"],\n    "prediction": ["struct_type_a *", "name1", "struct", {"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__uint8","v1"],\n    "prediction": ["enum_type_a","name1","enum",{"enum_type_a": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ]\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__int64 *","v1"],\n    "prediction": ["int","name1","array","4,4"] // array type, name, array size\n}\n</Output>\nThe prediction of the variable is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable is a complex type, such as struct, enum, and array, keep "" if not.\nIf multiple variables are analyzed, the output should be a list of the above format wrapped with one <Output>...</Output>.\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
vars = '1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\n\n5. Data Flow Analysis\nInferring the propagation path of each target variable (cross-function and inter-procedural analysis).\n\n6. Usage Patterns\nSummarize the usage patterns of each variable in target function.\nBased on the usage patterns, judge if the variable is a complex type, such as struct, enum, array, etc.\n\n7. Type Inference\nInfer the type of each variable within target function base on the data flow analysis and usage patterns.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n\n8. Name Recovery\nRecover the name of each variable within target function base on the analysis above.\n\n9. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result for each target variable.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n[\n    {\n        "original": ["__int64","v1"],\n        "prediction": ["int","name1","",{}] // type, name, is_complex_type?, and struct or enum details\n    },\n    {\n        "original": ["__int64","v2"],\n        "prediction": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__uint8","v3"],\n        "prediction": ["enum_type_b","name3","enum",{"enum_type_b": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__int64 *","v4"],\n        "prediction": ["int","name4","array","4,4"] // array type, name, array size\n    }\n    ...\n]\n</Output>\nThe prediction of the variable is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable is a complex type, such as struct, enum, and array, keep "" if not.\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
args = '1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\n\n5. Data Flow Analysis\nInferring the propagation path of each target argument (cross-function and inter-procedural analysis).\n\n6. Usage Patterns\nSummarize the usage patterns of each argument in target function.\nBased on the usage patterns, judge if the argument is a complex type, such as struct, enum, array, etc.\n\n7. Type Inference\nInfer the type of each argument within target function base on the data flow analysis and usage patterns.\nIf the type is structure, enum, or array, infer the detailed type information: structure fields, enum list, array length.\n\n8. Name Recovery\nRecover the name of each argument within target function base on the analysis above.\n\n9. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result for each target argument.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n[\n    {\n        "original": ["__int64","a1"],\n        "prediction": ["int","name1","",{}] // type, name, is_complex_type?, and struct or enum details\n    },\n    {\n        "original": ["__int64","a2"],\n        "prediction": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__uint8","a3"],\n        "prediction": ["enum_type_b","name3","enum",{"enum_type_b": [\n                    ["field1","value1",4], // item name, value, and size\n                    ["field2","value2",4],\n                    ...\n                    ]}\n                ]\n    },\n    {\n        "original": ["__int64 *","a4"],\n        "prediction": ["int","name4","array","4,4"] // array type, name, array size\n    },\n    {\n        "original": ["__int64","a5"],\n        "prediction": ["__int64","a5@del_arg","",{}] // delete the argument erroneously recovered by decompiler\n    }\n    {\n        "original": [],\n        "prediction": ["char *","name6@add_arg","",{}] / add the argument erroneously omitted by decompiler\n    }\n    ...\n]\n</Output>\nThe prediction of the argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the argument is a complex type, such as struct, enum, and array, keep "" if not.\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
funcname = '\n1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\nStart from the context functions, and then analyze the target function based on the calling context.\n\n5. Function Name Recovery\nInfer the possible function names for all functions based on the analysis above.\n\n6. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result.\nSummarize the final results wrapped with <Output>...</Output>, such as:\n<Output>\n[\n{"original": "sub_0xFuncAddr", "prediction": "foo"},\n...\n]\n</Output>\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
summary = '\n1. Understand the Task \nWhat should be analyzed in the task.\nList the objects within the target function should be analyzed base on the specific task, such as args, vars, func name, etc.\n\n2. Inspect the Calling Context\nDescribe the calling relationship of the functions.\nIf a function in context is a library function, describe its functionality and definition (including arguments and return type).\n\n3. Callsites Analysis\nAnalyze each caller of the target function, describing each argument passed into the target function.\nAnalyze each callsite within the target function, describing the arguments passed into each callee function.\n\n4. Analyze Function Semantics\nAnalyze the behavior of each function, end with detailed analysis of the target function.\nStart from the context functions, and then analyze the target function based on the calling context.\n\n5. Algorithm and Category Analysis\nAnalyze whether the target function implements a specific algorithm, or is a part of a specific algorithm.\nAnalyze what category the target function belongs to, such as logging, network, data processing, etc.\nIf it is not one of the well-defined ones, or if you are not sure, use "none".\n\n6. Comment Generation\n- a. Generate doxygen comments for the whole target function based on the analysis above, including brief, detailed, parameters, return.\n- b. Generate inline comments (end of the line) for the target function for only key lines based on the analysis above to help user understand the code. Only comment on the key lines, such as some callsites, some important variables and usages, beginning of some loops, etc.\n\n7. Review and Summary\nReview the analysis check reasoning process.\nDescribe the key basis for inferring the result.\nSummarize the final results wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "brief": "brief description",\n    "details": "detailed description",\n    "params": {\n        "arg1": "comment for arg1",\n        "arg2": "comment for arg2",\n        ...\n    },\n    "return": "return description",\n    "inline_comment": {\n        "3": "comment for L3",\n        "5": "comment for L5",\n        ...\n    },\n    "category": "functional category or none",\n    "algorithm": "algorithm name or none"\n}\n</Output>\nThe <Output>...</Output> shoud be the end of the reasoning process, and do not append more explain after it.\n'
func_analysis_output_format = '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "ret_type": "int",\n    "funcname": "foo", // recovered meaningful function name for meaningless original name\n    "args": {\n        "a1": ["int","name1","",{}], // type, name, is_complex_type?, and struct or enum details\n        "a2": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ],\n        "a3": ["enum_type_b","name3","enum",{"enum_type_b": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ],\n        "a4": ["char","name4","array","4,4"], // array type, name, array size\n        "a5@del_arg": [], // delete the argument erroneously recovered by decompiler\n        "a6@add_arg": [], // add the argument erroneously omitted by decompiler\n        ...\n    },\n    "vars": {\n        "var1": ["int","name5","",{}],\n        "var2": ["struct_type_b","name6","struct",{"struct_type_b": [\n                ["int","field3",4],\n                ["char","field4",1],\n                ...\n                ]}\n            ],\n        ...\n    },\n    "brief": "brief description",\n    "details": "detailed description",\n    "params": {\n        "a1": "comment for a1",\n        "a2": "comment for a2",\n        ...\n    },\n    "return": "return description",\n    "inline_comment": {\n        "3": "comment for L3",\n        "5": "comment for L5",\n        ...\n    },\n    "category": "functional category or none",\n    "algorithm": "algorithm name or none"\n}\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\n'
decompilation_output_format = '\nthe final results should be the decompiled source code with Doxygen comment wrapped with <Output>...</Output>, as well as the complex types recovered in the analysis, such as:\n<Output>\n```C\n/**\n * @brief brief description\n * @details detailed description\n * @param arg1 comment for arg1\n * @param arg2 comment for arg2\n * ...\n * @return return description\n * @category category\n * @algorithm algorithm\n */\nstruct struct_type_a { // present the complex types recovered in the analysis\n    ...\n}\nvoid foo(int arg1, struct_type_a arg2, ...) {\n    ...\n}\n```\n</Output>\n'
specific_vars_output_format = '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "original": ["__int64", "v1"], \n    "prediction": ["char", "name1", "", {}] // type, name, is_complex_type?, and struct or enum details\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__int64", "v1"],\n    "prediction": ["struct_type_a *", "name1", "struct", {"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__uint8","v1"],\n    "prediction": ["enum_type_a","name1","enum",{"enum_type_a": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ]\n}\n</Output>\nor\n<Output>\n{\n    "original": ["__int64 *","v1"],\n    "prediction": ["int","name1","array","4,4"] // array type, name, array size\n}\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\nIf multiple variables/arguments are analyzed, the output should be a list of the above format wrapped with one <Output>...</Output>.\n'
vars_output_format = '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n[\n    {\n        "original": ["__int64","v1"],\n        "prediction": ["int","name1","",{}] // type, name, is_complex_type?, and struct or enum details\n    },\n    {\n        "original": ["__int64","v2"],\n        "prediction": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__uint8","v3"],\n        "prediction": ["enum_type_b","name3","enum",{"enum_type_b": [\n                ["field1","value1",4], // item name, value, and size\n                ["field2","value2",4],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__int64 *","v4"],\n        "prediction": ["int","name4","array","4,4"] // array type, name, array size\n    }\n    ...\n]\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\n'
args_output_format = '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n[\n    {\n        "original": ["__int64","a1"],\n        "prediction": ["int","name1","",{}] // type, name, is_complex_type?, and struct or enum details\n    },\n    {\n        "original": ["__int64","a2"],\n        "prediction": ["struct_type_a *","name2","struct",{"struct_type_a": [\n                ["int","field1",4], // field type, field name, field size\n                ["char","field2",1],\n                ...\n                ]}\n            ]\n    },\n    {\n        "original": ["__uint8","a3"],\n        "prediction": ["enum_type_b","name3","enum",{"enum_type_b": [\n                    ["field1","value1",4], // item name, value, and size\n                    ["field2","value2",4],\n                    ...\n                    ]}\n                ]\n    },\n    {\n        "original": ["__int64 *","a4"],\n        "prediction": ["int","name4","array","4,4"] // array type, name, array size\n    },\n    {\n        "original": ["__int64","a5"],\n        "prediction": ["__int64","a5@del_arg","",{}] // delete the argument erroneously recovered by decompiler\n    }\n    {\n        "original": [],\n        "prediction": ["char *","name6@add_arg","",{}] / add the argument erroneously omitted by decompiler\n    }\n    ...\n]\n</Output>\nThe prediction of the variable/argument is a list including type, name, is_complex_type?, and complex type details, respectively.\nThe third element, is_complex_type?, indicates whether the variable/argument is a complex type, such as struct, enum, and array, keep "" if not.\n'
funcname_output_format = '\nThe final results should be wrapped with <Output>...</Output>, such as:\n<Output>\n[\n{"original": "sub_0xFuncAddr", "prediction": "foo"},\n...\n]\n</Output>\n'
summary_output_format = '\nThe final results should be wrapped with <Output>...</Output> in JSON format, such as:\n<Output>\n{\n    "brief": "brief description",\n    "details": "detailed description",\n    "params": {\n        "arg1": "comment for arg1",\n        "arg2": "comment for arg2",\n        ...\n    },\n    "return": "return description",\n    "inline_comment": {\n        "3": "comment for L3",\n        "5": "comment for L5",\n        ...\n    },\n    "category": "functional category or none",\n    "algorithm": "algorithm name or none"\n}\n</Output>\n'
TASK_GUIDES = {
    '<func-analysis>': func_analysis,
    '<decompilation>': decompilation,
    '<specific-vars>': specific_vars,
    '<vars>': vars,
    '<args>': args,
    '<funcname>': funcname,
    '<summary>': summary }
TASK_OUTPUT_FORMATS = {
    '<func-analysis>': func_analysis_output_format,
    '<decompilation>': decompilation_output_format,
    '<specific-vars>': specific_vars_output_format,
    '<vars>': vars_output_format,
    '<args>': args_output_format,
    '<funcname>': funcname_output_format,
    '<summary>': summary_output_format }
import random

def get_mock_response(task_tag):
    '__pyarmor_enter_54893__(...)'
    import json as _var_var_0
    import os as _var_var_1
    _var_var_2 = _var_var_1.path.dirname(__file__)
    _var_var_2 = _var_var_1.path.join(_var_var_2, 'debug_mock.json')
    if not _var_var_1.path.exists(_var_var_2):
        raise Exception('[!💥] mock response file not found, turn off Mock Mode in settings if you are not a developer.')
# WARNING: Decompyle incomplete

'__pyarmor_exit_54891__(...)'
